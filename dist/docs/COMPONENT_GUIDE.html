<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <title>Van Cone | Component guide</title>
      <link rel="stylesheet" href="/style.css" />
    </head>
    <body>
      <div class="container">
        <div class="content">
          <h1 id="van-cone--component-and-routing-guide">Van Cone | component and routing guide</h1>
          <p>In an effort to keep the VanJS ecosystem lightweight Van Cone does define a component object like many reactive frameworks however you will see that they are not necessary with Van Cone/VanJS. When the term component is used in Van Cone documentation it refers to a callable that takes a specific set of arguments from the Van Cone router and returns a tag element from Van JS, for example
            <code>van.tags.div</code>.</p>
          <p>In this guide you will find:</p>
          <ul>
            <li>
              <a href="#function-signature">component function definition</a>
            </li>
            <li>
              <a href="#hello-world-with-router">a hello world example</a>
            </li>
            <li>
              <a href="#url--query-params-example">a url and query param example</a>
            </li>
            <li>
              <a href="#full-component-example">a full component example with nav link component and context</a>
            </li>
            <li>
              <a href="#different-backend-endpoint">an example using a backend endpoint which is different than the frontend</a>
            </li>
            <li>
              <a href="#wildcard-not-found-page">wildcard / 404 not found</a>
            </li>
            <li>
              <a href="#define-the-routes-component-via-callable">define the route&#39;s component via callable</a>
            </li>
            <li>
              <a href="#define-the-routes-component-via-import">define the route&#39;s component via import</a>
            </li>
          </ul>
          <h1 id="component-functions">Component functions</h1>
          <p>A component function takes up to 3 arguments and returns a van js tag element. The Van Cone router will call this component function when activating the route.</p>
          <h2 id="function-signature">function signature</h2>
          <pre>
            <code class="language-javascript">const myComponent = (params, query, context) =&gt; div(...)</code>
          </pre>
          <p>
            <code>params</code>- an object of parameters parsed out of the url, see example below for defining the router. If no parameters were defined in the router this will be an empty object.</p>
          <p>
            <code>query</code>- an object of query string parameters, if none exist in the url this will be an empty object.</p>
          <p>
            <code>context</code>- additional context (for example prefetched data) can be passed to the component when navigating using the
            <a href="/docs/API_REFERENCE.html#linkprops-children">link component</a>or the programmatic navigation function
            <a href="/docs/API_REFERENCE.html#navigateroutename-options">navigate</a>. If none is provided this will be an empty object. Typically this would be an object but it could be any data type.</p>
          <h2 id="examples">examples</h2>
          <h3 id="the-hello-world">the hello world</h3>
          <pre>
            <code class="language-javascript">const homePage = () =&gt; div(&#39;Home Page&#39;)</code>
          </pre>
          <p>You obviously don&#39;t need a framework to do this, outside of the Van Cone router, components are generally not needed because they are simply a function that returns a van element. They are many ways to create re-usable components, component functions in Van Cone are only useful to create a concept of a page that integrates with the router.</p>
          <h3 id="hello-world-with-router">hello world with router</h3>
          <pre>
            <code class="language-javascript">const homePage = () =&gt; div(&#39;Home Page&#39;) const routes = [{ path: &quot;/&quot;, name: &quot;home&quot;, title: &quot;VanJS Example | Home&quot;, callable: async () =&gt; homePage }]</code>
          </pre>
          <h3 id="url--query-params-example">url + query params example</h3>
          <p>URL params are defined in the
            <code>path</code>property of the route object using a colon, query params are automatically parsed and passed to the component without needing to setup anything in the route. Currently query args are returned as raw strings and the component may need to do its own type validation/conversion.</p>
          <pre>
            <code class="language-javascript">// use url params to parse a user id const userPage = (params) =&gt; div(&#39;User Page&#39;, p(&#39;userId: &#39; + params.userId)) // use query params to define a sort on a list page const userListPage = (params, query) =&gt; div(&#39;User List&#39;, p(&#39;sort by: &#39; + query.sort)) const routes = [ { path: &quot;/user/:userId&quot;, name: &quot;user&quot;, title: &quot;VanJS Example | User&quot;, callable: async () =&gt; import(&#39;./app/pages/user&#39;) }, { path: &quot;/users&quot;, name: &quot;users&quot;, title: &quot;VanJS Example | User List&quot;, callable: async () =&gt; import(&#39;./app/pages/userList&#39;) } ]</code>
          </pre>
          <h3 id="full-component-example">full component example</h3>
          <p>Here is a full example showing url parameters, query parameters and additional context.</p>
          <p>Given the following route:</p>
          <pre>
            <code class="language-javascript">{ path: &quot;/user/:id&quot;, name: &quot;user&quot;, title: &quot;VanJS Example | User&quot;, callable: async () =&gt; import(&#39;./app/pages/user&#39;) }</code>
          </pre>
          <p>A component can use the data as follows:</p>
          <pre>
            <code class="language-javascript">const userPage = (params, query, context) =&gt; { /* our parent component, a search page may have passed in preloaded information via link, if not, we&#39;ll fetch it */ const userInfo = (context) ? context : fetchUserInfo(params.id) return div( p(&quot;Hi I am: &quot; + userInfo.name), p(&quot;some query string data: &quot; + query.data) ); }</code>
          </pre>
          <p>You can use the
            <a href="/docs/API_REFERENCE.html#linkprops-children">
              <code>link</code>
            </a>component to navigate to this page like this:</p>
          <pre>
            <code class="language-javascript">const data = {&#39;name&#39;: &#39;Mar√≠a&#39;} link({name: &#39;user&#39;, params: {id: 123}, query: {&#39;data&#39;: &#39;hello&#39;}, context: data}, &#39;User&#39;)</code>
          </pre>
          <h3 id="different-backend-endpoint">different backend endpoint</h3>
          <p>When data is fetched from a different endpoint provide a backend path as follows. See
            <a href="/docs/API_REFERENCE.html#backendurlroutename-params---query">backendUrl</a>for information on generating a backend url for fetching data.</p>
          <pre>
            <code class="language-javascript">const routes = [ { path: &quot;/user/:userId&quot;, backend: &quot;/api/user/:userId&quot;, name: &quot;user&quot;, title: &quot;VanJS Example | User&quot;, callable: async () =&gt; import(&#39;./app/pages/user&#39;) } ]</code>
          </pre>
          <h3 id="wildcard-not-found-page">wildcard (not found page)</h3>
          <pre>
            <code class="language-javascript">const routes = [{ path: &quot;.*&quot;, name: &quot;notFound&quot;, title: &quot;VanJS Example | Not Found&quot;, callable: async () =&gt; import(&#39;./app/pages/notFound&#39;) } ];</code>
          </pre>
          <h3 id="define-the-routes-component-via-callable">define the route&#39;s component via callable</h3>
          <p>The simplest way to define a route&#39;s component.</p>
          <pre>
            <code class="language-javascript">const homePage = () =&gt; div(&#39;Home Page&#39;) const routes = [{ path: &quot;/&quot;, name: &quot;home&quot;, title: &quot;VanJS Example | Home&quot;, callable: async () =&gt; homePage }]</code>
          </pre>
          <h3 id="define-the-routes-component-via-import">define the route&#39;s component via import</h3>
          <p>A route&#39;s component can also be returned via import.</p>
          <pre>
            <code class="language-javascript">// Define route const routes = [{ path: &quot;.*&quot;, name: &quot;home&quot;, title: &quot;VanJS Example | Home&quot;, callable: async () =&gt; import(&#39;./app/pages/homePage&#39;) } ];</code>
          </pre>
          <pre>
            <code class="language-javascript">// ./app/pages/homePage.js import van from &quot;vanjs-core&quot;; const { section, div, br, h1, img } = van.tags const homePage = () =&gt; { return section( h1(&quot;Welcome to this SPA demo using VanJS!&quot;), br(), div( { style: &quot;text-align:center;&quot; }, img({ src: vanLogo, alt: &quot;VanJS&quot;, style: &quot;height:100px;width:100px;&quot; }) ) ); }; export default homePage;</code>
          </pre>
          <p>Note that you can also use a non-default export like this:</p>
          <pre>
            <code class="language-javascript">const routes = [{ path: &quot;.*&quot;, name: &quot;home&quot;, title: &quot;VanJS Example | Home&quot;, callable: async () =&gt; import(&#39;./pageComponents&#39;).homePage } ];</code>
          </pre>
        </div>
      </div>
    </body>